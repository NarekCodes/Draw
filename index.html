<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Multiplayer Drawing Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; }
    body { display:flex; flex-direction:column; font-family:system-ui, sans-serif; }
    .toolbar {
      display:flex; gap:8px; align-items:center; padding:8px;
      border-bottom:1px solid #ddd; flex-wrap:wrap;
    }
    canvas { flex:1; display:block; touch-action:none; background:#fff; }
    button { padding:6px 10px; border-radius:8px; border:1px solid #ccc; cursor:pointer; }
    input[type="range"] { width:140px; }
    .spacer { flex:1 }
    #chatBox { height:100px; overflow:auto; border-top:1px solid #ddd; padding:4px; }
    #chatInput { flex:1; padding:4px; border-radius:4px; border:1px solid #ccc; }
  </style>
</head>
<body>
  <div class="toolbar">
    <label>Color <input id="color" type="color" value="#111111"></label>
    <label>Size <input id="size" type="range" min="1" max="32" value="4"></label>
    <select id="brushType">
      <option value="normal">Normal</option>
      <option value="marker">Marker</option>
      <option value="eraser">Eraser</option>
    </select>
    <button id="undo">Undo</button>
    <button id="redo">Redo</button>
    <button id="clear">Clear</button>
    <button id="replay">Replay</button>
    <button id="save">Save PNG</button>
    <div class="spacer"></div>
    <span id="status">ðŸŸ¢ Connected</span>
  </div>

  <canvas id="board"></canvas>

  <div style="display:flex; gap:4px; padding:4px; border-top:1px solid #ddd;">
    <input id="chatInput" placeholder="Type message..." />
    <button id="sendMsg">Send</button>
  </div>
  <div id="chatBox"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const canvas = document.getElementById("board");
    const ctx = canvas.getContext("2d");
    const colorEl = document.getElementById("color");
    const sizeEl  = document.getElementById("size");
    const brushTypeEl = document.getElementById("brushType");
    const clearEl = document.getElementById("clear");
    const undoEl = document.getElementById("undo");
    const redoEl = document.getElementById("redo");
    const saveEl = document.getElementById("save");
    const replayEl = document.getElementById("replay");
    const statusEl = document.getElementById("status");

    const chatInput = document.getElementById("chatInput");
    const chatBox = document.getElementById("chatBox");
    const sendMsg = document.getElementById("sendMsg");

    const socket = io();
    let strokes = [];
    let undone = [];
    let username = "";

    // Chat with username prompt
    sendMsg.addEventListener("click", () => {
      if (!username) {
        username = prompt("Enter your username:");
        if (!username) return; // cancel if empty
      }
      const msg = chatInput.value.trim();
      if (!msg) return;
      socket.emit("chat", { username, message: msg });
      chatInput.value = "";
    });

    socket.on("chat", (data) => {
      const p = document.createElement("p");
      if (typeof data === "string") {
        p.textContent = data;
      } else {
        p.textContent = `${data.username}: ${data.message}`;
      }
      chatBox.appendChild(p);
      chatBox.scrollTop = chatBox.scrollHeight;
    });

    // Canvas resize
    function resize() {
      const toolbarHeight = document.querySelector('.toolbar').offsetHeight;
      const chatHeight = 120;
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width  = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor((window.innerHeight - toolbarHeight - chatHeight) * dpr);
      canvas.style.height = (window.innerHeight - toolbarHeight - chatHeight) + "px";
      ctx.scale(dpr, dpr);
      redraw();
    }
    window.addEventListener("resize", resize);
    resize();

    // Drawing logic
    let drawing = false;
    let last = null;

    function getPos(e){
      if(e.touches && e.touches[0]){
        const r = canvas.getBoundingClientRect();
        return {x:e.touches[0].clientX - r.left, y:e.touches[0].clientY - r.top};
      } else {
        const r = canvas.getBoundingClientRect();
        return {x:e.clientX - r.left, y:e.clientY - r.top};
      }
    }

    function drawLine(x0,y0,x1,y1,color,size,type){
      ctx.lineCap="round"; ctx.lineJoin="round"; ctx.lineWidth=size;
      if(type==="eraser"){ ctx.globalCompositeOperation="destination-out"; ctx.strokeStyle="rgba(0,0,0,1)"; }
      else if(type==="marker"){ ctx.globalCompositeOperation="source-over"; ctx.strokeStyle=color; ctx.globalAlpha=0.5; }
      else { ctx.globalCompositeOperation="source-over"; ctx.strokeStyle=color; ctx.globalAlpha=1; }
      ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.stroke();
      ctx.globalAlpha=1;
    }

    function toNorm(p){ const r = canvas.getBoundingClientRect(); return {x:p.x/r.width, y:p.y/r.height}; }
    function fromNorm(p){ const r = canvas.getBoundingClientRect(); return {x:p.x*r.width, y:p.y*r.height}; }

    function start(e){ e.preventDefault(); drawing=true; last=getPos(e); }
    function move(e){
      if(!drawing) return; e.preventDefault();
      const now = getPos(e);
      drawLine(last.x,last.y,now.x,now.y,colorEl.value,+sizeEl.value,brushTypeEl.value);
      const data = {a:toNorm(last),b:toNorm(now),color:colorEl.value,size:+sizeEl.value,type:brushTypeEl.value};
      strokes.push(data);
      socket.emit("drawing",data);
      last=now;
    }
    function end(e){ drawing=false; last=null; }

    canvas.addEventListener("mousedown",start);
    window.addEventListener("mousemove",move);
    window.addEventListener("mouseup",end);
    canvas.addEventListener("touchstart",start,{passive:false});
    canvas.addEventListener("touchmove",move,{passive:false});
    canvas.addEventListener("touchend",end);

    function redraw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle="#ffffff";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      for(const s of strokes){
        const a=fromNorm(s.a), b=fromNorm(s.b);
        drawLine(a.x,a.y,b.x,b.y,s.color,s.size,s.type);
      }
    }

    // Undo/Redo
    undoEl.addEventListener("click",()=>{ if(strokes.length>0){ undone.push(strokes.pop()); redraw(); socket.emit("undo"); }});
    redoEl.addEventListener("click",()=>{ if(undone.length>0){ strokes.push(undone.pop()); redraw(); socket.emit("redo"); }});

    socket.on("drawing",(d)=>{ strokes.push(d); const a=fromNorm(d.a),b=fromNorm(d.b); drawLine(a.x,a.y,b.x,b.y,d.color,d.size,d.type); });
    socket.on("updateStrokes",(arr)=>{ strokes=arr.slice(); redraw(); });
    socket.on("clear",()=>{ strokes=[]; undone=[]; redraw(); });

    clearEl.addEventListener("click",()=>socket.emit("clear"));

    saveEl.addEventListener("click",()=>{ const link=document.createElement("a"); link.download="drawing.png"; link.href=canvas.toDataURL("image/png"); link.click(); });

    replayEl.addEventListener("click",()=>{
      if(strokes.length===0) return;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle="#ffffff";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      let i=0;
      const interval=setInterval(()=>{
        const s=strokes[i];
        const a=fromNorm(s.a), b=fromNorm(s.b);
        drawLine(a.x,a.y,b.x,b.y,s.color,s.size,s.type);
        i++;
        if(i>=strokes.length) clearInterval(interval);
      },50);
    });

    // Mobile chat handling
    chatInput.addEventListener("focus",()=>{ canvas.style.pointerEvents="none"; });
    chatInput.addEventListener("blur",()=>{ canvas.style.pointerEvents="auto"; });

    // Connection status
    socket.on("connect",()=>{ statusEl.textContent="ðŸŸ¢ Connected"; });
    socket.on("disconnect",()=>{ statusEl.textContent="ðŸ”´ Disconnected"; });

    socket.on("loadStrokes",(arr)=>{ strokes=arr.slice(); redraw(); });
  </script>
</body>
</html>
